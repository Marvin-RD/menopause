/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./_src/components/cookies-preferences/scripts/CookiesPreferences.js":
/*!***************************************************************************!*\
  !*** ./_src/components/cookies-preferences/scripts/CookiesPreferences.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _scripts_helpers_cookies_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../scripts/helpers/cookies.js */ \"./_src/scripts/helpers/cookies.js\");\n/* harmony import */ var _scripts_helpers_tryParseJSONObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scripts/helpers/tryParseJSONObject.js */ \"./_src/scripts/helpers/tryParseJSONObject.js\");\n/* harmony import */ var _scripts_helpers_ExpandableElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../scripts/helpers/ExpandableElement.js */ \"./_src/scripts/helpers/ExpandableElement.js\");\n\n\n\n\n/**\n * Cookies Preferences\n * TODO: Consider a decent way of avoiding loading JS (and styles?) for Cookies functionality unless needed.\n * TODO(cont): Typically we'd just check for the existence of the flag cookie (cookies-preferences-saved)...\n * TODO(cont): ... in PHP and not load the component, but this was causing some funky issues around resetting...\n * TODO(cont): ... preferences on Kinsta sites where cached HTML was being served without the component regardless of...\n * TODO(cont): ... the saved cookies-preferences-saved cookie value.\n *\n */\nclass CookiesPreferences {\n  constructor(element) {\n    this.el = element;\n\n    // Cookie info\n    this.cookieLifetime = 365; // Days\n    this.cookieName = 'cookies-consent';\n\n    // Key els, i.e. the form, inputs, and trigger buttons.\n    this.formEl = this.el;\n    this.consentTypeInputs = this.el.querySelectorAll('input[type=\"checkbox\"]');\n    this.consentAllButton = this.el.querySelector('.js-cookies-consent-all');\n    this.consentSelectedButton = this.el.querySelector('.js-cookies-consent-selected');\n    this.rejectAllButton = this.el.querySelector('.js-cookies-reject-all');\n    this.alertElShell = document.createElement('p');\n    this.alertElShell.setAttribute('role', 'alert');\n    this.alertElShell.classList.add('cookies-preferences__alert');\n    this.alertElShell.setAttribute('hidden', 'hidden');\n    this.preferencesSavedAlertEl = null;\n\n    // Feedback messages\n    this.feedbackText = (0,_scripts_helpers_tryParseJSONObject_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.el.dataset.feedbackText);\n    this.init();\n  }\n  init() {\n    this.consentAllButton.addEventListener('click', () => {\n      this.consentTypeInputs.forEach(element => {\n        element.checked = true;\n        this.updateActionsVisibility();\n      });\n    });\n    this.rejectAllButton.addEventListener('click', () => {\n      this.consentTypeInputs.forEach(element => {\n        element.checked = false;\n        this.updateActionsVisibility();\n      });\n    });\n    this.consentTypeInputs.forEach(element => {\n      element.addEventListener('change', () => {\n        this.updateActionsVisibility();\n      });\n    });\n    this.formEl.addEventListener('submit', e => {\n      e.preventDefault();\n      const formdata = new FormData(this.formEl);\n      const consentPreferences = {};\n      [...formdata.entries()].forEach(pair => {\n        if (pair[0].indexOf('gtm_consent_type_') === 0) {\n          // TODO: Consider making cookie consent type objects classes (e.g. CookiesPreference).\n          consentPreferences[pair[0]] = {\n            type: 'gtm_consent_type',\n            name: pair[0].replace('gtm_consent_type_', ''),\n            value: pair[1] === 'granted' ? 'granted' : 'denied'\n          };\n        } else {\n          consentPreferences[pair[0]] = {\n            type: 'custom',\n            name: pair[0],\n            value: pair[1]\n          };\n        }\n      });\n      this.savePreferences(consentPreferences);\n    });\n    this.updateFormInputsFromPreferences(this.getSavedPreferences());\n    document.addEventListener('cookiespreferencessaved', () => {\n      this.updateFormInputsFromPreferences(this.getSavedPreferences());\n    });\n    this.el.addEventListener('cookiespreferencessaved', () => {\n      const preferencesSavedText = document.createTextNode(this.feedbackText.preferencesSaved);\n      if (this.preferencesSavedAlertEl != null) {\n        this.preferencesSavedAlertEl.remove();\n      }\n      this.preferencesSavedAlertEl = this.alertElShell.cloneNode();\n      this.preferencesSavedAlertEl.appendChild(preferencesSavedText);\n      this.el.appendChild(this.preferencesSavedAlertEl);\n      setTimeout(() => {\n        this.preferencesSavedAlertEl.removeAttribute('hidden');\n      }, 1);\n\n      // Push an event we can pick up in GTM.\n      window.dataLayer = window.dataLayer || [];\n      window.dataLayer.push({\n        event: 'consentcookiechange'\n      });\n    });\n    this.groupsExpandableElTarget = this.el.querySelector('.js-expandable-element');\n    if (this.groupsExpandableElTarget instanceof Element) {\n      this.groupsExpandableEl = new _scripts_helpers_ExpandableElement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.groupsExpandableElTarget);\n      this.groupsExpandableEl.updateConfig({\n        focusWithinOnExpand: true\n      });\n    }\n  }\n  updateActionsVisibility() {\n    let checkedConsentTypes = 0;\n    this.consentTypeInputs.forEach((element, index) => {\n      if (element.checked) {\n        checkedConsentTypes += 1;\n      }\n      if (index === this.consentTypeInputs.length - 1) {\n        if (checkedConsentTypes === 0 || checkedConsentTypes === this.consentTypeInputs.length) {\n          this.consentAllButton.parentNode.setAttribute('aria-hidden', 'false');\n          this.consentSelectedButton.parentNode.setAttribute('aria-hidden', 'true');\n        } else {\n          this.consentAllButton.parentNode.setAttribute('aria-hidden', 'true');\n          this.consentSelectedButton.parentNode.setAttribute('aria-hidden', 'false');\n        }\n      }\n    });\n  }\n\n  // Update the form inputs based on some preferences\n  updateFormInputsFromPreferences(preferences, callback) {\n    this.consentTypeInputs.forEach((element, index) => {\n      if (Object.prototype.hasOwnProperty.call(preferences, element.name)) {\n        if (preferences[element.name].value === element.value) {\n          element.checked = true;\n        } else {\n          element.checked = false;\n        }\n      }\n      if (index === this.consentTypeInputs.length - 1) {\n        this.updateActionsVisibility();\n      }\n    });\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n  getSavedPreferences() {\n    const cookieData = (0,_scripts_helpers_cookies_js__WEBPACK_IMPORTED_MODULE_0__.getCookie)(this.cookieName);\n    let response = {};\n    response = (0,_scripts_helpers_tryParseJSONObject_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(cookieData);\n\n    // In case the cookie value has been saved as anything other than a JSON object.\n    if (response === false && cookieData !== '') {\n      (0,_scripts_helpers_cookies_js__WEBPACK_IMPORTED_MODULE_0__.setCookie)(this.cookieName, '', 0);\n    }\n    return response;\n  }\n\n  // Save our preferences in a cookie.\n  savePreferences(preferences) {\n    (0,_scripts_helpers_cookies_js__WEBPACK_IMPORTED_MODULE_0__.setCookie)(this.cookieName, JSON.stringify(preferences), this.cookieLifetime);\n    (0,_scripts_helpers_cookies_js__WEBPACK_IMPORTED_MODULE_0__.setCookie)(`${this.cookieName}-preferences-saved`, 1, this.cookieLifetime);\n    this.el.dispatchEvent(new Event('cookiespreferencessaved', {\n      bubbles: true,\n      cancelable: false\n    }));\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CookiesPreferences);\n\n//# sourceURL=webpack://reach/./_src/components/cookies-preferences/scripts/CookiesPreferences.js?");

/***/ }),

/***/ "./_src/scripts/helpers/ExpandableElement.js":
/*!***************************************************!*\
  !*** ./_src/scripts/helpers/ExpandableElement.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ExpandableElement),\n/* harmony export */   \"events\": () => (/* binding */ events)\n/* harmony export */ });\n/* harmony import */ var _Focusable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Focusable.js */ \"./_src/scripts/helpers/Focusable.js\");\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n/**\n * ExpandableElement\n *\n * Give the target element:\n * - [id=\"TARGET ELEMENT ID\"]\n *\n * Give all trigger elements:\n * - [aria-controls=\"TARGET ELEMENT ID\"]\n *\n * a11y overview of aria-expanded: https://www.accessibility-developer-guide.com/examples/sensible-aria-usage/expanded/\n */\nclass ExpandableElement {\n  constructor(target) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Bail early - required elements or markup not found.\n    if (!this.setUpRequiredElements(target)) {\n      return;\n    }\n\n    // Set instance options by combining default options with any overrides via spread syntax.\n    this.options = {\n      collapseOnEscape: true,\n      collapseOnFocusout: false,\n      collapseAncestorsOnEscape: false,\n      collapseOnAncestorCollapse: true,\n      focusWithinOnExpand: false,\n      updateChildTabIndexes: true,\n      setHiddenAttribute: true,\n      on: {},\n      ...options\n    };\n    this.lastTrigger = null;\n\n    // Helper object to manage focusable elements inside expandable element.\n    this.focusableItems = new _Focusable_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.targetElement);\n\n    // Handle expanding.\n    this.targetElement.addEventListener('expandbegin', this);\n    this.targetElement.addEventListener('expandend', this);\n\n    // Handle clicks - triggers and inside & outside target.\n    document.addEventListener('click', this);\n  }\n  updateConfig(newConfig) {\n    this.options = {\n      ...this.options,\n      ...newConfig\n    };\n  }\n  handlePotentialFocusLoss(event) {\n    if (!event.relatedTarget) {\n      return;\n    }\n    if (this.targetElement.contains(event.relatedTarget)) {\n      return;\n    }\n    if ([...this.triggerElements].includes(event.relatedTarget)) {\n      return;\n    }\n    this.collapse();\n  }\n  isExpanded() {\n    return !this.targetElement.hasAttribute('aria-hidden');\n  }\n  expand() {\n    this.targetElement.dispatchEvent(ExpandableElement.events.expandbegin);\n    this.targetElement.removeAttribute('aria-hidden');\n    if (this.options.setHiddenAttribute === true) {\n      this.targetElement.removeAttribute('hidden');\n    }\n    this.triggerElements.forEach(trigger => trigger.setAttribute('aria-expanded', 'true'));\n    if (this.options.updateChildTabIndexes === true) {\n      this.focusableItems.resetTabIndex();\n    }\n    this.targetElement.dispatchEvent(ExpandableElement.events.expandend);\n  }\n  collapse() {\n    this.targetElement.dispatchEvent(ExpandableElement.events.collapsebegin);\n    this.targetElement.setAttribute('aria-hidden', 'true');\n    if (this.options.setHiddenAttribute === true) {\n      this.targetElement.setAttribute('hidden', 'hidden');\n    }\n    this.triggerElements.forEach(trigger => trigger.setAttribute('aria-expanded', 'false'));\n    if (this.options.updateChildTabIndexes === true) {\n      this.focusableItems.hideAllFromKeyboard();\n    }\n    this.targetElement.dispatchEvent(ExpandableElement.events.collapseend);\n  }\n  toggle() {\n    if (this.isExpanded()) {\n      this.collapse();\n    } else {\n      this.expand();\n    }\n  }\n\n  /**\n   * Sets the ExpandableElement's required elements - a target and at least one trigger - returning success/failure.\n   *\n   * @param {node} target The required triggering element.\n   * @returns {boolean} Whether setting up the required elements was successful.\n   */\n  setUpRequiredElements(target) {\n    this.targetElement = target;\n\n    // Bail early - invalid target element passed.\n    if (!this.targetElement || !(this.targetElement instanceof HTMLElement)) {\n      console.error('Invalid target element', this.targetElement, this);\n      return false;\n    }\n    if (!this.targetElement.hasAttribute('id') || this.targetElement.id === '') {\n      console.error('Target element missing required \"id\" attribute', this.targetElement, this);\n      return false;\n    }\n    this.triggerElements = document.querySelectorAll(`[aria-controls=${this.targetElement.id}]`);\n\n    // Bail early - invalid trigger element passed.\n    if (!this.triggerElements || this.triggerElements.length < 1) {\n      console.error('No trigger elements found', this.triggerElements, this);\n      return false;\n    }\n    const isExpanded = this.isExpanded() ? 'true' : 'false';\n    this.triggerElements.forEach(trigger => {\n      // Improve accessibility of trigger element if it isn't a <button>.\n      if (trigger.tagName !== 'BUTTON') {\n        trigger.setAttribute('role', 'button');\n      }\n\n      // Ensure required accessibility attribute is set.\n      trigger.setAttribute('aria-expanded', isExpanded);\n    });\n    return true;\n  }\n\n  /**\n   * Handle events with class functions to retain class context.\n   *\n   * @link https://webreflection.medium.com/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\n   *\n   * @param {Event} event An event object.\n   */\n  handleEvent(event) {\n    this[`on${event.type}`](event);\n\n    // add event listeners from 'on' options\n    Object.keys(this.options.on).forEach(eventName => {\n      if (eventName === event.type) {\n        this.options.on[eventName](event);\n      }\n    });\n  }\n  onclick(event) {\n    if ([...this.triggerElements].includes(event.target)) {\n      this.lastTrigger = event.target;\n      this.toggle();\n    } else if (this.options.collapseOnFocusout === true && this.isExpanded() && !this.targetElement.contains(event.target)) {\n      this.collapse();\n    }\n  }\n  onfocusout(event) {\n    this.handlePotentialFocusLoss(event);\n  }\n  onblur(event) {\n    this.handlePotentialFocusLoss(event);\n  }\n  onkeydown(event) {\n    if (event.key !== 'Escape') {\n      return;\n    }\n    if (!this.targetElement.contains(event.target)) {\n      return;\n    }\n    this.collapse();\n\n    // Replace focus for keydown events.\n    if (this.lastTrigger) {\n      this.lastTrigger.focus();\n      this.lastTrigger = null;\n    }\n\n    // Conditionally prevent ancestor elements from collapsing.\n    if (this.options.collapseAncestorsOnEscape === false) {\n      event.stopPropagation();\n    }\n  }\n  oncollapsebegin() {\n    this.targetElement.removeEventListener('collapsebegin', this);\n    if (this.options.collapseOnFocusout === true) {\n      this.targetElement.removeEventListener('focusout', this);\n      this.triggerElements.forEach(trigger => trigger.removeEventListener('blur', this));\n    }\n    if (this.options.collapseOnEscape === true) {\n      this.targetElement.removeEventListener('keydown', this);\n    }\n    if (this.options.collapseOnAncestorCollapse === true) {\n      document.removeEventListener('collapseend', this);\n    }\n  }\n  oncollapseend(_ref) {\n    let {\n      target\n    } = _ref;\n    if (target === this.targetElement) {\n      // Stop handling ExpandableElement collapse.\n      this.targetElement.removeEventListener('collapseend', this);\n\n      // Handle ExpandableElement expand.\n      this.targetElement.addEventListener('expandbegin', this);\n      this.targetElement.addEventListener('expandend', this);\n    } else if (this.options.collapseOnAncestorCollapse === true && target.contains(this.targetElement)) {\n      this.collapse();\n    }\n  }\n  onexpandbegin() {\n    this.targetElement.removeEventListener('expandbegin', this);\n  }\n  onexpandend() {\n    // Stop handling ExpandableElement expand.\n    this.targetElement.removeEventListener('expandend', this);\n\n    // Start handling ExpandableElement collapse.\n    this.targetElement.addEventListener('collapsebegin', this);\n    this.targetElement.addEventListener('collapseend', this);\n    if (this.options.focusWithinOnExpand === true) {\n      window.setTimeout(() => {\n        // If the parent element was display:none, focus must be set after the parent element displays.\n        this.focusableItems.firstFocusable.focus();\n      }, 100);\n    }\n    if (this.options.collapseOnFocusout === true) {\n      this.targetElement.addEventListener('focusout', this);\n      this.triggerElements.forEach(trigger => trigger.addEventListener('blur', this));\n    }\n    if (this.options.collapseOnEscape === true) {\n      this.targetElement.addEventListener('keydown', this);\n    }\n    if (this.options.collapseOnAncestorCollapse === true) {\n      document.addEventListener('collapseend', this);\n    }\n  }\n\n  // Custom events for ExpandableElement state change listeners.\n}\n\n// Class custom events - standardised for use elsewhere.\n_defineProperty(ExpandableElement, \"events\", {\n  get collapsebegin() {\n    return new Event('collapsebegin');\n  },\n  get collapseend() {\n    return new Event('collapseend', {\n      bubbles: true\n    });\n  },\n  get expandbegin() {\n    return new Event('expandbegin');\n  },\n  get expandend() {\n    return new Event('expandend', {\n      bubbles: true\n    });\n  }\n});\nconst {\n  events\n} = ExpandableElement;\n\n//# sourceURL=webpack://reach/./_src/scripts/helpers/ExpandableElement.js?");

/***/ }),

/***/ "./_src/scripts/helpers/Focusable.js":
/*!*******************************************!*\
  !*** ./_src/scripts/helpers/Focusable.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Focusable)\n/* harmony export */ });\n// See https://github.com/zellwk/javascript/blob/master/src/browser/accessibility/focusable.js\nfunction Focusable() {\n  let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;\n  return {\n    get length() {\n      return this.keyboardOnly.length;\n    },\n    get all() {\n      return [...element.querySelectorAll(`\n                    a,\n                    button,\n                    input,\n                    textarea,\n                    select,\n                    details,\n                    iframe,\n                    embed,\n                    object,\n                    summary dialog,\n                    audio[controls],\n                    video[controls],\n                    [contenteditable],\n                    [tabindex]\n                `)].filter(el => {\n        return el instanceof HTMLElement && !el.hasAttribute('disabled') && !el.hasAttribute('hidden') && el.style.display !== 'none';\n      });\n    },\n    get keyboardOnly() {\n      return this.all.filter(el => el.tabIndex > -1);\n    },\n    get firstFocusable() {\n      return this.keyboardOnly[0];\n    },\n    get lastFocusable() {\n      return this.keyboardOnly[this.length - 1];\n    },\n    set tabIndex(index) {\n      this.all.forEach(el => {\n        el.tabIndex = index;\n      });\n    },\n    hideAllFromKeyboard() {\n      this.tabIndex = -1;\n    },\n    resetTabIndex() {\n      this.all.forEach(el => {\n        el.removeAttribute('tabindex');\n      });\n    }\n  };\n}\n\n//# sourceURL=webpack://reach/./_src/scripts/helpers/Focusable.js?");

/***/ }),

/***/ "./_src/scripts/helpers/cookies.js":
/*!*****************************************!*\
  !*** ./_src/scripts/helpers/cookies.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getCookie\": () => (/* binding */ getCookie),\n/* harmony export */   \"setCookie\": () => (/* binding */ setCookie)\n/* harmony export */ });\n// Get a Date a number of days in the future.\nconst getFutureDateFromDays = days => new Date(Date.now() + days * 24 * 60 * 60 * 1000);\n\n// Get a future date as a UTC string.\nconst getFutureUTCStringFromDays = days => getFutureDateFromDays(days).toUTCString();\n\n// Create a key-value string for a cookie attribute.\nconst formatCookiePropVal = (key, value) => `${key}=${value};`;\n\n// Set a cookie with a given lifetime (in days).\nconst setCookie = function (name, value, lifetime) {\n  let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';\n  let domain = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  let secure = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  let samesite = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'strict';\n  let cookie = formatCookiePropVal(name, value) + formatCookiePropVal('expires', getFutureUTCStringFromDays(lifetime)) + formatCookiePropVal('path', path) + formatCookiePropVal('SameSite', samesite);\n  if (typeof domain === 'string') {\n    cookie += formatCookiePropVal('Domain', domain);\n  }\n  if (secure === true) {\n    cookie += 'Secure';\n  }\n  document.cookie = cookie;\n};\n\n// Retrieve a cookie value by name. Empty string if not found.\nconst getCookie = name => {\n  const nameFormatted = `${name}=`;\n  const cookies = document.cookie.split(';');\n  for (let i = cookies.length - 1; i > -1; i -= 1) {\n    let cookie = cookies[i];\n    while (cookie.charAt(0) === ' ') {\n      cookie = cookie.substring(1);\n    }\n    if (cookie.indexOf(nameFormatted) === 0) {\n      return cookie.substring(nameFormatted.length, cookie.length);\n    }\n  }\n  return '';\n};\n\n\n//# sourceURL=webpack://reach/./_src/scripts/helpers/cookies.js?");

/***/ }),

/***/ "./_src/scripts/helpers/tryParseJSONObject.js":
/*!****************************************************!*\
  !*** ./_src/scripts/helpers/tryParseJSONObject.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ tryParseJSONObject)\n/* harmony export */ });\n/**\n * Using JSON.parse() when you don't know if it's a JSON string throws errors...\n * Solution below from https://stackoverflow.com/a/20392392/4479336\n * ---\n * If you don't care about primitives and only objects then this function\n * is for you, otherwise look elsewhere.\n * This function will return `false` for any valid JSON primitive.\n * EG, 'true' -> false\n *     '123' -> false\n *     'null' -> false\n *     '\"I'm a string\"' -> false\n */\nfunction tryParseJSONObject(JSONString) {\n  try {\n    const o = JSON.parse(JSONString);\n\n    // Handle non-exception-throwing cases:\n    // Neither JSON.parse(false) or JSON.parse(1234) throw errors, hence the type-checking,\n    // but... JSON.parse(null) returns null, and typeof null === \"object\",\n    // so we must check for that, too. Thankfully, null is falsey, so this suffices:\n    if (o && typeof o === 'object') {\n      return o;\n    }\n  } catch (e) {\n    // console.log('Could not parse JSON from string.');\n  }\n  return false;\n}\n\n//# sourceURL=webpack://reach/./_src/scripts/helpers/tryParseJSONObject.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./_src/components/cookies-preferences/scripts/CookiesPreferences.js");
/******/ 	
/******/ })()
;